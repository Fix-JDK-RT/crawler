В данном материале собраны основные концепции и принципы современного JavaScript, которые помогут быстро найти и вспомнить необходимую фичу.В JavaScript переменные объявляют при помощи трёх операторов. При этом заданные через const переменные изменить нельзя, а через var и let — можно. Поэтому если в коде предстоит изменить значение переменной, задавайте её с помощью let, если нет — через const.Область переменных функции обозначает рамки их использования в коде.Другой пример, демонстрирующий рамки области переменных:Переменные при выполнении оператора присваивания перемещаются в начало, что называется «поднятие переменных». Часть кода:при выполнении понимается как:Вот как это работает для не доступных до присвоения переменных, объявленных операторами let и const:Переменные, объявленные с помощью var, доступны до присвоения. При использовании let и const — только после него. Этот феномен получил название «Временные мёртвые зоны». Кроме того, с помощью оператора let нельзя объявить другую переменную:Однако тонкость заключается в том, что вы можете изменить значение объявленной оператором const переменной для объектов:и массивов:Стрелочные функции ввели в обновлении ES6 как альтернативный способ объявления и использования функций.Традиционный код отличается наличием ключевого слова:Поскольку перед return нет команд, стрелочные функции позволяют избежать дополнительной строки:Мы убрали скобки и ключевое слово, но вывод всё равно x * 2. Если функция не возвращает значение (имеет побочные эффекты), это происходит ни явно, ни неявно. При необходимости возврата объекта, его заключают в скобки:Теперь в том же коде используем стрелочные функции:С выходом версии ES2015 значение по умолчанию для параметра функции задаётся при помощи следующего синтаксиса:Параметр по умолчанию применяется в двух случаях: когда он не задан или задан параметр undefined. При введении null параметр по умолчанию не применится.Деструктурирование — создание новых переменных путём извлечения данных из объектов и массивов. Например, извлечение параметров this.props из React-проектов.Без деструктурирования:Применяя деструктурирование:Извлекая параметр person, получим компактную функцию:Со стрелочными функциями код становится существенно меньше:Без деструктурирования он выглядит так:С деструктурированием:Методы массивов пришли в JavaScript из функционального программирования. Используя три этих метода, вы избегаете циклов for и forEach в большинстве ситуаций. Попробуйте вместо for использовать совокупность map, filter и reduce. В первый раз будет сложно, потому что придётся научиться мыслить иначе, но дальше привыкнете. Посчитаем для примера сумму оценок студентов с результатом 10 и выше, используя три этих метода:Для более детального наглядного объяснения возьмём массив:Что мы тут сделали? .map выполняет итерацию каждого элемента массива numbers и перемещает их в функцию. Цель функции — обработать и вернуть новую переменную, чтобы map мог заменить её.Теперь посмотрим на функцию отдельно, чтобы было понятнее:Метод часто используется со стрелочными функциями:Используем numbers.map(doubleN) и получаем, что равно [0, 2, 4, 6, 8, 10, 12].В случае если возвращать массив нет необходимости и нужен цикл с побочными эффектами, используйте for/forEach.Метод также часто используется со стрелочными функциями:.filter осуществляет итерацию каждого элемента массива numbers и добавляет их в функцию. Цель функции — вернуть булево значение и определить, нужно оно или нет. После чего фильтр возвращает массив только с добавленными значениями.Метод также часто используется со стрелочными функциями:.reduce применяется к массиву и использует функцию как первый параметр. Однако в данном случае мы сталкиваемся с исключениями:Ступени итерации:Его добавили в обновлении ES2015, чтобы элементы итерации (например массива) можно было использовать в качестве нескольких элементов в коде.Возьмём два массива:В arr2 первый аргумент — массив, поскольку читает содержимое arr1. Но нам нужно сделать arr2 массивом, состоящим из последовательности букв. Для этого используем spread и получим необходимый результат:Давайте предположим, что нам нужно добавить студента с его оценками и посчитать средний балл. Не лучше ли сделать два параметра двумя разными значениями, а затем собрать массив из полученных данных для итерации? В этом нам и поможет оставшийся параметр.Зададим переменную для свойств объекта. Если её имя совпадёт с названием свойства, можно сделать следующее:Если вы объявляли объектный литерал в версиях до ES2015 или хотели использовать переменную в качестве значения свойств объекта, то пришлось бы писать:Слишком много повторений, не так ли? Поэтому с выходом ES2015 при совпадении переменной с названием свойства, достаточно такого кода:Промис — это объект, который используется для упорядочивания синхронных и асинхронных операций. При использовании промисов код становится чище, поэтому они всё чаще встречаются в проектах.AJAX-запрос при выполнении не является синхронным, поскольку ответ от ресурса идёт какое-то время. Он может вообще не прийти, если ресурс не доступен (404). Для решения этой проблемы в ES2015 добавили промисы, которые принимают 3 состояния:Представим, что нам нужно создать Ajax-запрос до ресурса X. Используем для этого метод jQuery.get():Объект Promise выполняет функцию executor с аргументами resolve и reject. Эти аргументы выполняются по завершении операции как и функции, которые переводят промис из состояния ожидания в состояние выполнения или отклонения. Функция executor выполняется сразу после создания промиса в статусе ожидания. Как только аргументами функции становятся resolve или reject, промис использует необходимые методы.Используем методы промиса, чтобы получить его выполнение или ошибку:В случае сдержанного промиса выполняется resolve и функция с методом .then. Иначе выполняется reject и функция с методом .catch. Также обработчик будет выполнен при сдержанном или нарушенном промисе, что приведёт к отсутствию «состояния гонки» между завершением асинхронной операции и применением обработчика.Допускают использование строковой интерполяции и многострочных литералов. Другими словами, это синтаксис, допускающий использование выражений JavaScript внутри строк.Являются расширенной формой шаблонных литералов и позволяют разбирать их с помощью функции. При вызове функции первый аргумент содержит массив строковых значений между интерполированными значениями. Чтобы уместить их все, используйте оператор spread (...). Библиотека styled-components написана с применением теговых шаблонов.Ниже приведён небольшой пример их работы:Другой интересный пример:Экспорт функций/объектов из модулей ES6 и импорт значений из них.Несмотря на внешнюю схожесть именных импортов с деструктурированием, синтаксис отличается. Они не поддерживают значения по умолчанию или вложенное деструктурирование. Кроме того, можно использовать дополнительное имя, но синтаксис отличается от используемого при деструктурировании:Для одного модуля доступен один экспорт по умолчанию. Экспорт может быть функцией, классом, объектом и т.д. Значение рассматривается как «основное», поскольку так его проще импортировать:Экспорт функции:Поведение этого ключевого слова в JavaScript отличается от других языков и зависит от вызова функции.JavaScript — прототип-ориентированный язык программирования. Классы ввели как синтаксический сахар для прототип-ориентированного наследования в ES6. Слово «класс» смутит вас, если вы знакомы с классами в других языках программирования. Попробуйте посмотреть иначе: прочитайте о прототипах и их поведении в JavaScript. До ES6 синтаксис прототипов выглядел следующим образом:С синтаксисом классов в ES6:Ключевое слово extends используют для объявления классов или в выражениях класса для создания дочерних классов. Они получают свойства родительских классов, а также дают возможность добавить новые свойства и изменить заимствованные.Ключевое слово super вызывает функции родителя объекта, включая его конструктор. Его следует использовать:Если бы мы попытались использовать this перед super() в классе Square, появилась бы ошибка ReferenceError:Для написания асинхронного кода в JavaScript появился синтаксис async/await. Цель нововведения — упростить использование промисов и расширить рамки действий с ними. Для лучшего понимания этого синтаксиса, рекомендуем сначала ознакомиться с промисами. await может использоваться только внутри асинхронной функции.async/await используется с промисами, но предполагают более императивный стиль кода. Оператор async определяет асинхронную функцию и всегда возвращает промис. Оператор await приостанавливает выполнение функции async, пока промис не выполнен или отклонён:Если в асинхронной функции достигается значение return, промис приобретает возвращённое значение. При выводе ошибки промис переходит в статус «отклонён». В то же время при отсутствии возвращённого значения асинхронной функции, промис возвращается без значения по завершению выполнения асинхронной функции.Оператор await ожидает выполнения промиса.Функция fetch позволяет выполнить AJAX-запрос.Выберем пользователя GitHub с помощью промисов и функции fetch:А теперь эквивалент с использованием async/await:Async/await подходят в случае с цепочкой взаимосвязанных промисов. Например можно использовать их для получения токена, чтобы выделить пост блога в базе данных, а также информацию об авторе:Если не добавить блоки try/catch к выражению await, неперехваченные исключения будут отклонять промис, возвращённый асинхронной функцией. При этом неважно, находятся ли они внутри асинхронной функции или возникли во время await. Использование throw внутри асинхронной функции равноценно отклонённому промису.Вот так можно устранить ошибки при помощи промисов:то же самое, но с async/await:Значения, похожие на правду и на ложь в JavaScript, относятся к логическим выражениям. Пример логического выражения — проверка значения оператора if. Значению присваивается true, если оно не равно:Примеры логических выражений:myVar может быть объектом первого класса (переменной, функцией, логическим значением), но будет считаться логическим выражением, поскольку проверяется в его контексте.Оператор возвращает false, если одиночный операнд может стать истинным; иначе возвращает true.myVar проверяется в контексте логического значения.Будьте осторожны, сравнивая 2 значения. Значения объекта (которые должны стать истинными) не считаются логическими, но конвертируются в примитивный тип данных. При сравнении объекта с логическим значением, например [] == true, он преобразуется в [].toString() == true:Ещё один способ записать функцию downToOne — использовать генератор. Эти функции могут приостанавливать выполнение, вернуть промежуточный результат, а затем продолжить выполнение в любой момент. Чтобы инстанцировать объект-генератор, необходимо объявить функцию function *. Перепишем функцию downToOne с использованием генератора:Генераторы возвращают итерируемые объекты. Функция next() выполняется до ключевого слова yield, которое возвращает значение во внешний код. Либо до функции yield *, которая передаёт её другой функции-генератору. При возврате результата return функция-генератор считается завершённой. Дальнейшие вызовы функции next() не вернут новых значений.Ключевое слово yield * активирует следующую функцию-генератор во время итерации:Ключевое слово static используется в классах для определения статичных методов. Статичные методы функции, принадлежащие объекту класса, но не доступные другим объектам того же класса.Вызов статического метода из другого статического метода осуществляется с помощью ключевого слова this. Для нестатических методов этот подход не сработает:Вызов статического метода из нестатического метода производится двумя способами:Читайте также:10 консольных команд для упрощения отладки JavaScript-кодаДетальный список инструментов для JavaScript Перевод статьи Modern JavaScript CheatsheetАртем ГавриловЗагрузка...Только самые важные IT-новостиВы успешно подтвердили свою подписку на «Аргументы и функции».Ждите первое письмо, оно придёт уже совсем скоро!«Аргументы и функции» — обзор самого важного из мира разработки. Даже не нужно переходить по ссылкам, просто прочитать одно письмо. Присылаем каждый день, по вечерам.Выглядит это примерно так: